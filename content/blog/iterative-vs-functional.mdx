---
path: '/iterative-vs-functional'
title: 'Manipulación de arrays iterativa vs funcional'
date: '2020-03-15'
description: 'Manipular arrays en Javascript es una operación común, se puede realizar de forma iterativa o funcional, aprende cual es mejor y porqué.'
image: '/images/blog/iterative-vs-functional.png'
keywords: 'Aprender, Javascript, Desarrollo Web, Iterativo, Funcional, Arrays, .map, .filter, .find, .every, .some, mutar array'
published: true
---

Debemos tener cuidado con la manipulación de **arrays** debido a qué los arrays se almacenan en memoria por referencia, esto significa que si igualamos dos arrays y modificamos uno de ellos, "ambos" serán cambiados ya que ambos apuntan a la misma referencia.

```js
const numbers = [1, 4, 2, 9];
const moreNumbers = numbers;

// Eliminamos la primera posición de moreNumbers
moreNumbers.shift();

console.log(numbers); // [4, 2, 9]
console.log(moreNumbers); // [4, 2, 9]
```

Por este motivo, debemos tener cuidado cuando trabajamos con **arrays** (objetos en general), si quisieramos
hacer la operación previa tendríamos que crear un nuevo **array** con los valores del **array** previo, hay varias
formas de conseguir esto pero mi preferida sin duda, usa la [sintáxis spread](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Operadores/Sintaxis_Spread).

```js
const numbers = [1, 4, 2, 9];
const moreNumbers = [...numbers]; // "Volcamos" los valores del array numbers al nuevo array

// Eliminamos la primera posición de moreNumbers
moreNumbers.shift();

console.log(numbers); // [1, 4, 2, 9]
console.log(moreNumbers); // [4, 2, 9]
```

Por este motivo, cuando trabajamos con **arrays** es mejor utilizar funciones como `.map()`, `.filter()`,
`.reduce()`, `.find()`, etc...

Por ejemplo, imaginemos que tenemos un **array** de usuarios y queremos encontrar todos los que sean
mayores de edad, esta operación es algo muy común, tenemos varias formas de hacerlo, de forma **iterativa**
o de forma **funcional**.

```js
const users = [
  { name: 'Pablo', age: 40 },
  { name: 'Rodrigo', age: 17 },
  { name: 'María', age: 18 }
];

const legalUsers = [];
for (let i = 0; i < users.length; i++) {
  if (users[i].age >= 18) {
    legalUsers.push(users[i]);
  }
}
```

Así podriamos hacerlo de forma **iterativa**, ahora veamos la forma **funcional**.

```js
const users = [
  { name: 'Pablo', age: 40 },
  { name: 'Rodrigo', age: 17 },
  { name: 'María', age: 18 }
];

const legalUsers = users.filter(
  user => user.age >= 18
);
```

Lo anterior demuestra la potencia que estos métodos tienen, si por ejemplo quisieramos ordenar el **array** de usuarios
por edad de menor a mayor podríamos hacerlo con `.sort()`, hay que tener cuidado ya que este muta el **array** original.

```js
const users = [
  { name: 'Pablo', age: 40 },
  { name: 'Rodrigo', age: 17 },
  { name: 'María', age: 18 }
];

const legalUsers = [...users].sort(
  (a, b) => a.age - b.age
);
```

Fácil verdad? Si quieres saber más acerca de cómo funciona este método, [aquí](https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/sort)
se explica muy bien, estamos haciendo **spread** de `users` ya que así no modificamos el **array** original,
[esta web](https://doesitmutate.xyz/) tiene información acerca de cuáles de estos métodos mutan o no el
**array** original.
