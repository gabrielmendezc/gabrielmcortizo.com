---
path: '/how-to-handle-state-and-cache-in-apollo'
title: 'Como manejar el estado y cach√© en React con Apollo Client y GraphQL'
date: '2020-03-12'
description: 'Manejar el estado en React cuando usamos Apollo Client puede resultar dudoso si no estamos acostumbrados, en este art√≠culo explico como podemos enfocar este problema.'
image: '/images/graphql-logo.png'
keywords: 'Javascript, Desarrollo web, GraphQL, Apollo Client, React, Apollo Cache, Apollo state, React hooks'
published: true
---

La soluci√≥n m√°s popular con diferencia para la integraci√≥n de un **cliente GraphQL** en nuestra aplicaci√≥n **React** es [Apollo Client](https://www.apollographql.com/docs/react/), uno de los motivos por los que es tan popular es su **cach√© inteligente**, este _cachea_ los resultados que nuestras operaciones (consultas, mutaciones y subscripciones) devuelven sin nosotros indicarselo, claro que esto est√° muy bien pero tambien presenta algunos problemas, veamos los _pros y cons_ <span role="img" aria-label="abajo">üëá</span>

## Pros

- Muy buena experiencia de usuario.
- Menos carga tanto para el cliente como para el servidor.
- No tenemos que preocuparnos de _cachear_ todo a mano.
- Datos centralizados en un √∫nico lugar (_single source of truth_).
- Facilidad de analizar y _testear_ este **cach√©** con las [herramientas de desarrollador de Apollo](https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm).

## Cons

- Dificultad de mantener el cach√© sincronizado con los datos del servidor.
- P√©rdida de control sobre si queremos leer del cach√© o pedir datos al servidor.

Ahora que tenemos claros los pros y cons, veamos como podemos abordar estos cons y convertirlos en pros.

### Dificultad de mantener el cach√© sincronizado.

Imaginemos que queremos obtener todos los usuarios de nuestra aplicaci√≥n, lo que haremos ser√° ejecutar una **consulta GraphQL** en nuestro servidor y mostrar los datos que nos devuelva en el cliente, el c√≥digo para esto podr√≠a ser algo as√≠:

```jsx
const GET_USERS_QUERY = gql`
  query getUsers {
    id
    username
  }
`;

export const UsersComponent = () => {
  const { data, loading, error } = useQuery(GET_USERS_QUERY);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error</p>;

  return (
    <ul>
      {data.getUsers.map(({ id, username }) => (
        <li key={id}>{username}</li>
      ))}
    </ul>
  );
};
```

La primera vez que este componente se monte en pantalla, se realizar√° la solicitud al servidor y se mostrar√°n los datos despu√©s de x tiempo, pero si volvemos a montar el componente, no se realizar√° la solicitud y se leer√° el cach√©, lo que consigue que los datos se muestren instant√°neamente, sin solicitudes extra.

Perfecto, pero, ¬øqu√© pasa si creamos un nuevo usuario desde otra parte de la aplicaci√≥n? Lo que pasar√° es que la pr√≥xima vez que se monte nuestro componente `UsersComponent`, veremos datos desactualizados, ya que en el servidor existe un nuevo usuario pero en el cach√© no. Entonces, veamos como podemos solucionar este problema sin tener que forzar al **cliente GraphQL** a realizar otra solicitud al servidor con los nuevos datos.

```jsx
const CREATE_USER_MUTATION = gql`
	mutation createUser($username: String!) {
		createUser(username: $username) {
			id
			username
		}
	}
`;

export const CreateUserComponent = () => {
	...

	const [createUser, { loading, error }] = useMutation(CREATE_USER_MUTATION, {
		update(cache, { data }) {
			if (!data) return;

			try {
				// Desestructuramos los datos del usuario creado.
				const { createUser: newUser } = data;

				const { getUsers: currentUsers } = cache.readQuery({
					query: GET_USERS_QUERY
				});

				// Actualizamos cach√© con nuevo usuario
				cache.writeQuery({
					query: GET_USERS_QUERY,
					data: {
						getUsers: [...currentUsers, newUser]
					}
				});
			} catch (error) {
				console.log('La query GET_USERS_QUERY no est√° en cach√©');
			}
		}
	});

	...
};
```

**Nunca** debemos mutar el cach√© viejo, sino clonarlo y a√±adirlo con los nuevos datos del cach√©, tal y como se est√° haciendo en el `writeQuery({ ... })`, otra cosa muy importante es que cada actualizaci√≥n del cach√© debe ir en su propio bloque `try/catch`, el motivo de esto es porque cuando intentamos leer algo del cach√© si ese algo no existe en el cach√©, lanzar√° un error que crashear√° la aplicaci√≥n a no ser que lo capturemos, esperemos que los desarrolladores de **Apollo Client** modifiquen esto para que devuelva un valor _falsy_ en vez de lanzar un error.

Para m√°s documentaci√≥n acerca de interacciones con el cach√©, puedes visitar la [documentaci√≥n de Apollo Client](https://www.apollographql.com/docs/react/caching/cache-interaction/).

### P√©rdida de control sobre si queremos leer datos del cach√© o del servidor.

[Apollo Client](https://www.apollographql.com/docs/react/) nos ofrece un conjunto de opciones para definir si queremos leer del cach√© o del servidor, las opciones son las siguientes:

- `cache-first`: Valor por defecto, se intenta leer del cach√© primero, en caso de que los datos no est√©n en cach√©, se har√° una petici√≥n al servidor y se guardar√°n en cach√© los datos devueltos.

- `cache-and-network`: Igual que `cache-first` solo que esta opci√≥n siempre har√° una petici√≥n al servidor aunque los datos est√©n en cach√©, esto est√° bien porque mantiene sincronizados los datos del cach√© con los datos del servidor, aunque tambi√©n nos cuesta una petici√≥n m√°s al servidor.

- `network-only`: _Siempre_ pedir√° los datos del servidor, nunca lee del cach√©, hay que tener en cuenta que aunque no use el cach√© para devolver los datos, s√≠ que escribe al cach√© la consulta.

- `cache-only`: _Nunca_ pedir√° los datos del servidor aunque no est√©n en cach√©, el problema de esto es mantener el cach√© sincronizado con el servidor, est√° explicado en la anterior secci√≥n como resolver este problema, aunque no siempre es posible.

- `no-cache`: Funciona exactamente igual que `network-only` con la diferencia de que no escribir√° nada al cach√©.

Por ejemplo, si solo queremos los datos del servidor y no queremos escribir al cach√© podr√≠amos hacer lo siguiente:

```jsx
export const SomeComponent = () => {
	...

	const { data, loading, error } = useQuery(SOME_QUERY,
		{ fetchPolicy: 'no-cache' }
	);

	...
};
```

## Conclusi√≥n

Debes de ver cual soluci√≥n es m√°s √≥ptima en tu situaci√≥n, con suerte, este art√≠culo te ayudar√° a decidir. En cuanto al estado, guardar los datos relacionados con **GraphQL** en el cach√© propio de **Apollo Client** y otros datos no relacionados en algo como [Context](https://es.reactjs.org/docs/context.html) me parece la soluci√≥n m√°s √≥ptima, si vas a usar **Apollo Client**, porfavor usa su cach√© y no metas algo como **Redux** por medio <span role="img" aria-label="rezo">üôè</span>
